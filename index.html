<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mermaid Hover Detail Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/panzoom@9/dist/panzoom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Meiryo', sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255,255,255,0.15);
            padding: 15px 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.3rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            color: #ffffff;
        }

        .header p {
            opacity: 0.85;
            font-size: 0.8rem;
            margin-top: 3px;
            color: #ffffff;
        }

        .btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        .container {
            display: flex;
            height: calc(100vh - 70px);
            padding: 15px;
            gap: 0;
        }

        .panel {
            background: rgba(255,255,255,0.06);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .panel-header {
            background: rgba(255,255,255,0.08);
            padding: 10px 14px;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            flex-shrink: 0;
            color: rgba(255,255,255,0.8);
        }

        .panel-content {
            flex: 1;
            padding: 12px;
            overflow: auto;
            min-height: 0;
        }

        textarea {
            width: 100%;
            height: 100%;
            background: #0f0f23;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #a8e6cf;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            padding: 10px;
            resize: none;
            line-height: 1.5;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102,126,234,0.2);
        }

        /* Left column - input panels */
        .left-column {
            display: flex;
            flex-direction: column;
            width: 35%;
            min-width: 250px;
            gap: 0;
        }

        .input-panel-top {
            flex: 1;
            min-height: 100px;
        }

        .input-panel-bottom {
            flex: 1;
            min-height: 100px;
        }

        /* Right column - output panels */
        .right-column {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 300px;
            gap: 0;
            transition: flex-direction 0.3s ease;
        }

        /* Horizontal layout mode for right column */
        .right-column.horizontal-layout {
            flex-direction: row;
        }

        .right-column.horizontal-layout .diagram-panel {
            flex: 2;
            min-width: 200px;
            min-height: unset;
            height: 100%;
        }

        .right-column.horizontal-layout .detail-panel {
            flex: 1;
            min-width: 200px;
            min-height: unset;
            height: 100%;
        }

        .right-column.horizontal-layout #resizer-right-v {
            width: 12px;
            height: auto;
            cursor: col-resize;
            margin: 0 2px;
        }

        .right-column.horizontal-layout #resizer-right-v::after {
            left: 5px;
            top: 0;
            bottom: 0;
            width: 2px;
            height: auto;
            border-radius: 1px;
        }

        .diagram-panel {
            flex: 2;
            min-height: 150px;
        }

        .detail-panel {
            flex: 1;
            min-height: 100px;
        }

        #diagram-output {
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 1px 1px, rgba(168, 85, 247, 0.15) 1px, transparent 0);
            background-size: 20px 20px;
            background-color: rgba(255,255,255,0.95);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        #diagram-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            padding: 20px;
        }

        #diagram-output svg {
            max-width: none;
            max-height: none;
        }

        /* Edge label styling */
        #diagram-output .edgeLabel {
            background: transparent !important;
        }

        #diagram-output .edgeLabel foreignObject {
            overflow: visible;
        }

        /* Style for edge labels with text */
        #diagram-output .edgeLabel span {
            background: linear-gradient(135deg, #f8fafc, #f1f5f9) !important;
            padding: 4px 10px !important;
            border-radius: 12px !important;
            font-size: 11px !important;
            font-weight: 600 !important;
            color: #475569 !important;
            border: 1px solid #cbd5e1 !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
            display: inline-block !important;
        }

        .zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }

        .zoom-btn {
            min-width: 30px;
            height: 30px;
            padding: 0 8px;
            border: none;
            border-radius: 6px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: translateY(-1px);
        }

        .zoom-info {
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            display: flex;
            align-items: center;
        }

        .detail-placeholder {
            color: #64748b;
            font-style: italic;
            text-align: center;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            opacity: 0.7;
        }

        .detail-active {
            animation: fadeIn 0.2s ease;
            padding: 5px;
        }

        .detail-node-id {
            display: inline-block;
            background: linear-gradient(135deg, #818cf8, #22d3ee);
            color: #ffffff;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(129, 140, 248, 0.4);
        }

        .detail-text {
            line-height: 1.7;
            color: #e2e8f0;
            font-size: 0.9rem;
            padding: 14px;
            background: linear-gradient(135deg, rgba(129, 140, 248, 0.1), rgba(34, 211, 238, 0.05));
            border-radius: 10px;
            border-left: 3px solid;
            border-image: linear-gradient(to bottom, #818cf8, #22d3ee) 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-3px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Resizer handles */
        .resizer {
            background: transparent;
            flex-shrink: 0;
            position: relative;
        }

        :root {
            --resizer-accent: rgba(168, 85, 247, 0.5);
        }

        .resizer::after {
            content: '';
            position: absolute;
            background: transparent;
            transition: background 0.2s;
        }

        .resizer:hover::after,
        .resizer.active::after {
            background: var(--resizer-accent);
        }

        .resizer-horizontal {
            width: 12px;
            cursor: col-resize;
            margin: 0 2px;
        }

        .resizer-horizontal::after {
            left: 5px;
            top: 0;
            bottom: 0;
            width: 2px;
            border-radius: 1px;
        }

        .resizer-vertical {
            height: 12px;
            cursor: row-resize;
            margin: 2px 0;
        }

        .resizer-vertical::after {
            top: 5px;
            left: 0;
            right: 0;
            height: 2px;
            border-radius: 1px;
        }

        /* SVG node hover styles */
        .node {
            cursor: pointer;
            transition: filter 0.2s ease, transform 0.2s ease;
        }

        .node:hover {
            filter: brightness(1.05) drop-shadow(0 6px 16px rgba(196, 181, 253, 0.4));
        }

        .node-highlight rect,
        .node-highlight polygon,
        .node-highlight circle,
        .node-highlight ellipse,
        .node-highlight path {
            stroke: var(--highlight-color, #a78bfa) !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 12px var(--highlight-glow, rgba(196, 181, 253, 0.6)));
        }

        /* Locked node style - dynamic color matching node's gradient */
        .node-locked rect,
        .node-locked polygon,
        .node-locked circle,
        .node-locked ellipse,
        .node-locked path {
            stroke: var(--lock-color, #22d3ee) !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 16px var(--lock-glow, rgba(34, 211, 238, 0.6)));
        }

        .node-locked {
            animation: pulse-lock 2s ease-in-out infinite;
            --pulse-glow: var(--lock-glow, rgba(34, 211, 238, 0.5));
        }

        @keyframes pulse-lock {
            0%, 100% { filter: brightness(1.05) drop-shadow(0 4px 12px var(--pulse-glow, rgba(34, 211, 238, 0.3))); }
            50% { filter: brightness(1.1) drop-shadow(0 6px 20px var(--pulse-glow, rgba(34, 211, 238, 0.5))); }
        }

        .error-message {
            color: #ff6b6b;
            background: rgba(255,107,107,0.1);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.8rem;
        }

        /* Keyboard shortcut hint */
        .shortcut-hint {
            font-size: 0.7rem;
            opacity: 0.6;
            margin-left: 10px;
        }

        /* Theme selector styling */
        #theme-selector {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.15);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #theme-selector:hover {
            background: rgba(255,255,255,0.25);
            transform: translateY(-1px);
        }

        #theme-selector option {
            background: #1a1a2e;
            color: #eee;
            padding: 8px;
        }

        /* Global transitions for theme switching - limited to specific properties for performance */
        body, .header, .panel, .panel-header, #diagram-output {
            transition: background 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        textarea, .detail-text {
            transition: color 0.3s ease, background-color 0.3s ease;
        }

        /* No select during resize */
        .resizing {
            user-select: none;
            cursor: col-resize !important;
        }

        .resizing.row-resize {
            cursor: row-resize !important;
        }

        .resizing * {
            user-select: none;
            pointer-events: none;
        }

        .resizing .resizer {
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>Mermaid Hover Detail Viewer</h1>
            <p>ノードをホバーで詳細表示・クリックで固定 | 枠線ドラッグでサイズ・レイアウト調整</p>
        </div>
        <div style="display: flex; align-items: center; gap: 15px;">
            <select id="theme-selector" onchange="changeTheme(this.value)">
                <option value="glassmorphism" selected>Glassmorphism Dark</option>
                <option value="minimal">Soft Minimal Light</option>
            </select>
            <button class="btn" onclick="renderDiagram()">Render</button>
            <span class="shortcut-hint">Ctrl+Enter</span>
        </div>
    </div>

    <div class="container" id="main-container">
        <!-- Left Column: Input panels -->
        <div class="left-column" id="left-column">
            <div class="panel input-panel-top" id="panel-mermaid">
                <div class="panel-header">Mermaid Code</div>
                <div class="panel-content">
                    <textarea id="mermaid-input" placeholder="flowchart LR
    A[fa:fa-play Start] --> B{Decision}">flowchart LR
    START([fa:fa-user User]) --> AUTH{fa:fa-lock Auth?}

    AUTH -->|No| LOGIN[fa:fa-sign-in-alt Login]
    LOGIN --> VALIDATE{fa:fa-check Valid?}
    VALIDATE -->|No| ERROR[fa:fa-times Error]
    ERROR --> LOGIN
    VALIDATE -->|Yes| SESSION[fa:fa-key Session]

    AUTH -->|Yes| CHECK{fa:fa-shield-alt Permission}
    SESSION --> CHECK

    CHECK -->|Admin| ADMIN[fa:fa-user-shield Admin]
    CHECK -->|User| USER[fa:fa-user User]
    CHECK -->|Guest| GUEST[fa:fa-user-clock Guest]

    ADMIN --> AUDIT[fa:fa-clipboard-list Log]
    USER --> AUDIT
    GUEST --> AUDIT

    AUDIT --> API{fa:fa-server API}
    API -->|OK| RENDER[fa:fa-paint-brush Render]
    API -->|Fail| RETRY{fa:fa-redo Retry?}
    RETRY -->|Yes| API
    RETRY -->|No| CACHE[fa:fa-database Cache]
    CACHE --> RENDER

    RENDER --> END([fa:fa-flag-checkered Done])

    %% Pastel Node Styles
    classDef startEnd fill:#d1fae5,stroke:#6ee7b7,color:#065f46,stroke-width:2px
    classDef decision fill:#fef3c7,stroke:#fcd34d,color:#92400e,stroke-width:2px
    classDef process fill:#e0e7ff,stroke:#a5b4fc,color:#3730a3,stroke-width:2px
    classDef error fill:#fee2e2,stroke:#fca5a5,color:#991b1b,stroke-width:2px
    classDef success fill:#dcfce7,stroke:#86efac,color:#166534,stroke-width:2px
    classDef warning fill:#fef9c3,stroke:#fde047,color:#854d0e,stroke-width:2px
    classDef info fill:#dbeafe,stroke:#93c5fd,color:#1e40af,stroke-width:2px
    classDef special fill:#f3e8ff,stroke:#d8b4fe,color:#6b21a8,stroke-width:2px

    %% Apply Styles
    class START,END startEnd
    class AUTH,VALIDATE,CHECK,API,RETRY decision
    class LOGIN,SESSION,ADMIN,USER,GUEST,AUDIT,RENDER process
    class ERROR error
    class CACHE warning</textarea>
                </div>
            </div>

            <!-- Vertical resizer between input panels -->
            <div class="resizer resizer-vertical" id="resizer-left-v" data-resizer="left-v"></div>

            <div class="panel input-panel-bottom" id="panel-details">
                <div class="panel-header">Node Details (JSON)</div>
                <div class="panel-content">
                    <textarea id="details-input" placeholder='{
    "A": "Description for node A",
    "B": "Description for node B"
}'>{
    "START": "User accesses the application via browser or API endpoint.",
    "AUTH": "Check if user has valid session token in cookies/localStorage.",
    "LOGIN": "Display login form with email/password fields. Support SSO options.",
    "VALIDATE": "Verify credentials against database. Check password hash with bcrypt.",
    "ERROR": "Show validation error message. Increment failed attempt counter.",
    "SESSION": "Generate JWT token with 24h expiry. Store refresh token in HttpOnly cookie.",
    "CHECK": "Validate user role from JWT claims. Check against RBAC policy.",
    "ADMIN": "Full access dashboard with user management, analytics, and system settings.",
    "USER": "Standard dashboard with personal data, settings, and basic features.",
    "GUEST": "Read-only view with limited functionality. Prompt to register.",
    "AUDIT": "Log user action to audit trail. Include timestamp, IP, and user agent.",
    "API": "Make REST API call to backend service. Timeout: 30s, Retry: 3 times.",
    "RENDER": "Build HTML response with React/Vue components. Apply user preferences.",
    "RETRY": "Exponential backoff: 1s, 2s, 4s. Check circuit breaker status.",
    "CACHE": "Load last successful response from Redis cache. Show stale indicator.",
    "END": "Request cycle complete. Total time logged to metrics service."
}</textarea>
                </div>
            </div>
        </div>

        <!-- Horizontal resizer between columns -->
        <div class="resizer resizer-horizontal" id="resizer-main" data-resizer="main"></div>

        <!-- Right Column: Output panels -->
        <div class="right-column" id="right-column">
            <div class="panel diagram-panel" id="panel-diagram">
                <div class="panel-header">Diagram</div>
                <div class="panel-content">
                    <div id="diagram-output">
                        <div id="diagram-container"></div>
                        <div class="zoom-controls">
                            <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
                            <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">-</button>
                            <button class="zoom-btn" onclick="fitToView()" title="Fit to View">F</button>
                            <button class="zoom-btn" onclick="resetZoom()" title="Reset to 100%">1:1</button>
                            <span class="zoom-info" id="zoom-level">100%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Vertical resizer between output panels -->
            <div class="resizer resizer-vertical" id="resizer-right-v" data-resizer="right-v"></div>

            <div class="panel detail-panel" id="panel-detail">
                <div class="panel-header">Node Detail</div>
                <div class="panel-content" id="detail-output">
                    <div class="detail-placeholder">Hover to see details / Click to lock</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Mermaid with custom theme
        mermaid.initialize({
            startOnLoad: false,
            theme: 'base',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: false,
                htmlLabels: true,
                curve: 'basis',
                padding: 20,
                nodeSpacing: 50,
                rankSpacing: 60
            },
            themeVariables: {
                // Base colors
                primaryColor: '#6366f1',
                primaryTextColor: '#ffffff',
                primaryBorderColor: '#4f46e5',

                // Lines and arrows
                lineColor: '#94a3b8',

                // Secondary elements
                secondaryColor: '#f1f5f9',
                secondaryTextColor: '#334155',
                secondaryBorderColor: '#cbd5e1',

                // Tertiary
                tertiaryColor: '#fef3c7',
                tertiaryTextColor: '#92400e',
                tertiaryBorderColor: '#fbbf24',

                // Background
                background: '#ffffff',
                mainBkg: '#f8fafc',

                // Node styling
                nodeBorder: '#4f46e5',
                clusterBkg: '#f1f5f9',
                clusterBorder: '#e2e8f0',

                // Text
                titleColor: '#1e293b',
                edgeLabelBackground: 'transparent',

                // Font
                fontFamily: '"Segoe UI", "Meiryo", sans-serif',
                fontSize: '14px'
            }
        });

        let nodeDetails = {};
        let currentHighlight = null;
        let panzoomInstance = null;
        let lockedNodeId = null;  // Locked node ID (persists after mouse leave)
        let lockedNodeElement = null;  // Locked node element reference

        // ========== Diagram Rendering ==========

        async function renderDiagram() {
            const mermaidCode = document.getElementById('mermaid-input').value;
            const detailsJson = document.getElementById('details-input').value;
            const container = document.getElementById('diagram-container');

            try {
                nodeDetails = JSON.parse(detailsJson);
            } catch (e) {
                nodeDetails = {};
                console.warn('Invalid JSON for node details:', e);
            }

            // Destroy existing panzoom instance
            if (panzoomInstance) {
                panzoomInstance.dispose();
                panzoomInstance = null;
            }

            container.innerHTML = '';

            try {
                const id = 'mermaid-' + Date.now();
                const { svg } = await mermaid.render(id, mermaidCode);
                container.innerHTML = svg;
                applyGradients();
                setupHoverEvents();
                showDetail(null);
                initPanzoom();
            } catch (error) {
                container.innerHTML = `<div class="error-message">Render Error: ${error.message}</div>`;
            }
        }

        // ========== Apply Gradients to SVG ==========

        function applyGradients() {
            const svgElement = document.querySelector('#diagram-container svg');
            if (!svgElement) return;

            // Create defs element for gradients
            let defs = svgElement.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                svgElement.insertBefore(defs, svgElement.firstChild);
            }

            // Define pastel gradients
            const gradients = {
                'grad-mint': ['#d1fae5', '#a7f3d0', '#6ee7b7'],
                'grad-peach': ['#fef3c7', '#fde68a', '#fcd34d'],
                'grad-lavender': ['#e0e7ff', '#c7d2fe', '#a5b4fc'],
                'grad-rose': ['#fee2e2', '#fecaca', '#fca5a5'],
                'grad-sky': ['#dbeafe', '#bfdbfe', '#93c5fd'],
                'grad-violet': ['#f3e8ff', '#e9d5ff', '#d8b4fe'],
                'grad-lime': ['#ecfccb', '#d9f99d', '#bef264'],
                'grad-amber': ['#fef9c3', '#fef08a', '#fde047']
            };

            // Add gradient definitions
            Object.entries(gradients).forEach(([id, colors]) => {
                const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                gradient.setAttribute('id', id);
                gradient.setAttribute('x1', '0%');
                gradient.setAttribute('y1', '0%');
                gradient.setAttribute('x2', '100%');
                gradient.setAttribute('y2', '100%');

                colors.forEach((color, i) => {
                    const stop = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop.setAttribute('offset', `${i * 50}%`);
                    stop.setAttribute('stop-color', color);
                    gradient.appendChild(stop);
                });

                defs.appendChild(gradient);
            });

            // Apply gradients based on node classes
            const nodes = svgElement.querySelectorAll('.node');
            nodes.forEach(node => {
                const shapes = node.querySelectorAll('rect, polygon, circle, ellipse, path');
                const classList = node.getAttribute('class') || '';

                let gradientId = 'grad-lavender'; // default

                if (classList.includes('startEnd') || node.id?.includes('START') || node.id?.includes('END')) {
                    gradientId = 'grad-mint';
                } else if (classList.includes('decision') || node.querySelector('polygon')) {
                    gradientId = 'grad-peach';
                } else if (classList.includes('error') || node.id?.includes('ERROR')) {
                    gradientId = 'grad-rose';
                } else if (classList.includes('warning') || node.id?.includes('FALLBACK')) {
                    gradientId = 'grad-amber';
                } else if (classList.includes('special')) {
                    gradientId = 'grad-violet';
                } else if (classList.includes('info')) {
                    gradientId = 'grad-sky';
                }

                shapes.forEach(shape => {
                    if (shape.tagName !== 'path' || shape.getAttribute('fill') !== 'none') {
                        shape.setAttribute('fill', `url(#${gradientId})`);
                    }
                });
            });

            // Helper function to extract node ID from element
            function extractNodeIdFromElement(node) {
                let id = node.id;
                if (id) {
                    const match = id.match(/flowchart-([^-]+)-\d+|node-([^-]+)/);
                    if (match) return match[1] || match[2];
                    return id.replace(/^(flowchart-|node-)/, '').replace(/-\d+$/, '');
                }
                return null;
            }

            // Map gradient IDs to stroke colors for edges
            const gradientToStroke = {
                'grad-mint': '#6ee7b7',
                'grad-peach': '#fcd34d',
                'grad-lavender': '#a5b4fc',
                'grad-rose': '#fca5a5',
                'grad-sky': '#93c5fd',
                'grad-violet': '#d8b4fe',
                'grad-lime': '#bef264',
                'grad-amber': '#fde047'
            };

            // Build node ID to gradient mapping
            const nodeGradientMap = {};
            nodes.forEach(node => {
                const nodeId = extractNodeIdFromElement(node);
                if (nodeId) {
                    const shape = node.querySelector('rect, polygon, circle, ellipse, path');
                    if (shape) {
                        const fill = shape.getAttribute('fill') || '';
                        for (const gradId of Object.keys(gradientToStroke)) {
                            if (fill.includes(gradId)) {
                                nodeGradientMap[nodeId] = gradId;
                                break;
                            }
                        }
                    }
                }
            });

            // Color edges based on source node
            // Mermaid uses .edgePaths > path with class "LS-{SourceNode} LE-{TargetNode}"
            const edgePaths = svgElement.querySelectorAll('.edgePaths path');
            edgePaths.forEach((path) => {
                const classList = path.getAttribute('class') || '';

                // Extract source node from "LS-{NodeId}" pattern in class
                const sourceMatch = classList.match(/LS-([A-Za-z0-9_]+)/);
                if (sourceMatch && sourceMatch[1]) {
                    const sourceNodeId = sourceMatch[1];
                    const gradId = nodeGradientMap[sourceNodeId];
                    if (gradId && gradientToStroke[gradId]) {
                        path.setAttribute('stroke', gradientToStroke[gradId]);
                    }
                }
            });

            // Color arrow markers based on source node
            const markers = svgElement.querySelectorAll('marker path');
            markers.forEach(marker => {
                const markerId = marker.closest('marker')?.id || '';
                const match = markerId.match(/flowchart-[^-]+-([A-Za-z0-9_]+)-/);
                if (match) {
                    const sourceNodeId = match[1];
                    const gradId = nodeGradientMap[sourceNodeId];
                    if (gradId && gradientToStroke[gradId]) {
                        marker.setAttribute('fill', gradientToStroke[gradId]);
                        marker.setAttribute('stroke', gradientToStroke[gradId]);
                    }
                }
            });

            // Style edge labels
            const edgeLabelRects = svgElement.querySelectorAll('.edgeLabel rect, .edgeLabel polygon');
            edgeLabelRects.forEach(el => {
                el.setAttribute('fill', 'transparent');
                el.setAttribute('stroke', 'none');
            });

            // Style the actual label text spans
            const edgeLabelSpans = svgElement.querySelectorAll('.edgeLabel span, .edgeLabel tspan');
            edgeLabelSpans.forEach(span => {
                const text = span.textContent?.trim();
                if (text && text.length > 0) {
                    span.style.background = 'linear-gradient(135deg, #f8fafc, #e2e8f0)';
                    span.style.padding = '4px 10px';
                    span.style.borderRadius = '12px';
                    span.style.fontSize = '11px';
                    span.style.fontWeight = '600';
                    span.style.color = '#475569';
                    span.style.border = '1px solid #cbd5e1';
                    span.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
                    span.style.display = 'inline-block';
                }
            });

            // Fix SVG sizing issues (remove max-width that causes cutoff)
            svgElement.style.maxWidth = 'none';
            svgElement.style.overflow = 'visible';

            // Ensure SVG has proper viewBox based on content
            const bbox = svgElement.getBBox();
            const padding = 20;
            const viewBoxWidth = bbox.x + bbox.width + padding;
            const viewBoxHeight = bbox.y + bbox.height + padding;

            svgElement.setAttribute('viewBox', `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
            svgElement.setAttribute('width', viewBoxWidth);
            svgElement.setAttribute('height', viewBoxHeight);
        }

        // ========== Pan & Zoom ==========

        function initPanzoom() {
            const container = document.getElementById('diagram-container');
            const outputEl = document.getElementById('diagram-output');
            const svgElement = container.querySelector('svg');

            if (!svgElement) return;

            // Calculate fit scale
            let svgWidth, svgHeight;

            if (svgElement.hasAttribute('width') && svgElement.hasAttribute('height')) {
                svgWidth = parseFloat(svgElement.getAttribute('width'));
                svgHeight = parseFloat(svgElement.getAttribute('height'));
            } else if (svgElement.viewBox.baseVal) {
                svgWidth = svgElement.viewBox.baseVal.width;
                svgHeight = svgElement.viewBox.baseVal.height;
            } else {
                const bbox = svgElement.getBBox();
                svgWidth = bbox.width;
                svgHeight = bbox.height;
            }

            const containerRect = outputEl.getBoundingClientRect();
            const padding = 60;
            const availableWidth = containerRect.width - padding;
            const availableHeight = containerRect.height - padding;

            const scaleX = availableWidth / svgWidth;
            const scaleY = availableHeight / svgHeight;
            const fitScale = Math.min(scaleX, scaleY);

            panzoomInstance = panzoom(svgElement, {
                maxZoom: 5,
                minZoom: 0.1,
                initialZoom: fitScale,
                bounds: false,
                boundsPadding: 0.1,
                smoothScroll: false
            });

            panzoomInstance.on('zoom', () => updateZoomLevel());
            updateZoomLevel();
        }

        function updateZoomLevel() {
            if (!panzoomInstance) return;
            const transform = panzoomInstance.getTransform();
            const percent = Math.round(transform.scale * 100);
            document.getElementById('zoom-level').textContent = percent + '%';
        }

        function zoomIn() {
            if (!panzoomInstance) return;
            const transform = panzoomInstance.getTransform();
            panzoomInstance.smoothZoom(
                window.innerWidth / 2,
                window.innerHeight / 2,
                1.3
            );
            setTimeout(updateZoomLevel, 100);
        }

        function zoomOut() {
            if (!panzoomInstance) return;
            panzoomInstance.smoothZoom(
                window.innerWidth / 2,
                window.innerHeight / 2,
                0.7
            );
            setTimeout(updateZoomLevel, 100);
        }

        function resetZoom() {
            if (!panzoomInstance) return;
            panzoomInstance.moveTo(0, 0);
            panzoomInstance.zoomAbs(0, 0, 1);
            setTimeout(updateZoomLevel, 100);
        }

        function fitToView() {
            if (!panzoomInstance) return;

            const container = document.getElementById('diagram-container');
            const outputEl = document.getElementById('diagram-output');
            const svgElement = container.querySelector('svg');

            if (!svgElement) return;

            // Dispose and recreate panzoom to reset completely
            panzoomInstance.dispose();

            // Get the original SVG dimensions from attributes or viewBox
            let svgWidth, svgHeight;

            if (svgElement.hasAttribute('width') && svgElement.hasAttribute('height')) {
                svgWidth = parseFloat(svgElement.getAttribute('width'));
                svgHeight = parseFloat(svgElement.getAttribute('height'));
            } else if (svgElement.viewBox.baseVal) {
                svgWidth = svgElement.viewBox.baseVal.width;
                svgHeight = svgElement.viewBox.baseVal.height;
            } else {
                const bbox = svgElement.getBBox();
                svgWidth = bbox.width;
                svgHeight = bbox.height;
            }

            const containerRect = outputEl.getBoundingClientRect();
            const padding = 60;
            const availableWidth = containerRect.width - padding;
            const availableHeight = containerRect.height - padding;

            const scaleX = availableWidth / svgWidth;
            const scaleY = availableHeight / svgHeight;
            const fitScale = Math.min(scaleX, scaleY);

            // Reinitialize panzoom with the fit scale
            panzoomInstance = panzoom(svgElement, {
                maxZoom: 5,
                minZoom: 0.1,
                initialZoom: fitScale,
                bounds: false,
                boundsPadding: 0.1,
                smoothScroll: false
            });

            panzoomInstance.on('zoom', () => updateZoomLevel());
            updateZoomLevel();
        }

        function setupHoverEvents() {
            const svgElement = document.querySelector('#diagram-output svg');
            if (!svgElement) return;

            const nodes = svgElement.querySelectorAll('.node');

            // Reset lock state when re-rendering
            lockedNodeId = null;
            lockedNodeElement = null;

            nodes.forEach(node => {
                const nodeId = extractNodeId(node);

                if (nodeId) {
                    node.style.cursor = 'pointer';

                    // Click to lock/unlock detail display
                    node.addEventListener('click', (e) => {
                        e.stopPropagation();

                        if (lockedNodeId === nodeId) {
                            // Clicking same node unlocks
                            unlockNode();
                        } else {
                            // Lock this node
                            lockNode(nodeId, node);
                        }
                    });

                    node.addEventListener('mouseenter', () => {
                        highlightNode(node);
                        showDetail(nodeId);
                    });

                    node.addEventListener('mouseleave', () => {
                        // Only unhighlight if not locked, or if this isn't the locked node
                        if (lockedNodeId !== nodeId) {
                            unhighlightNode(node);
                        }

                        // Show locked node detail if exists, otherwise show placeholder
                        if (lockedNodeId) {
                            showDetail(lockedNodeId);
                            // Re-highlight locked node
                            if (lockedNodeElement) {
                                highlightNode(lockedNodeElement);
                            }
                        } else {
                            showDetail(null);
                        }
                    });
                }
            });

            // Click outside nodes to unlock
            svgElement.addEventListener('click', (e) => {
                if (!e.target.closest('.node')) {
                    unlockNode();
                }
            });
        }

        function lockNode(nodeId, nodeElement) {
            // Clear previous lock highlight
            if (lockedNodeElement && lockedNodeElement !== nodeElement) {
                lockedNodeElement.classList.remove('node-locked');
                lockedNodeElement.style.removeProperty('--lock-color');
                lockedNodeElement.style.removeProperty('--lock-glow');
            }

            lockedNodeId = nodeId;
            lockedNodeElement = nodeElement;

            // Detect node color and set matching lock effect
            const lockColors = getNodeLockColor(nodeElement);
            nodeElement.style.setProperty('--lock-color', lockColors.stroke);
            nodeElement.style.setProperty('--lock-glow', lockColors.glow);

            nodeElement.classList.add('node-locked');
            showDetail(nodeId);
            showLockHint('Locked: ' + nodeId);
        }

        // Detect node's gradient/color and return matching lock effect colors
        function getNodeLockColor(nodeElement) {
            const shape = nodeElement.querySelector('rect, polygon, circle, ellipse, path');
            if (!shape) return { stroke: '#22d3ee', glow: 'rgba(34, 211, 238, 0.6)' };

            const fill = shape.getAttribute('fill') || '';

            // Match gradient ID to corresponding accent color
            const colorMap = {
                'grad-mint':     { stroke: '#34d399', glow: 'rgba(52, 211, 153, 0.6)' },   // Emerald
                'grad-peach':    { stroke: '#fbbf24', glow: 'rgba(251, 191, 36, 0.6)' },   // Amber
                'grad-lavender': { stroke: '#818cf8', glow: 'rgba(129, 140, 248, 0.6)' }, // Indigo
                'grad-rose':     { stroke: '#fb7185', glow: 'rgba(251, 113, 133, 0.6)' }, // Rose
                'grad-sky':      { stroke: '#38bdf8', glow: 'rgba(56, 189, 248, 0.6)' },  // Sky
                'grad-violet':   { stroke: '#a78bfa', glow: 'rgba(167, 139, 250, 0.6)' }, // Violet
                'grad-lime':     { stroke: '#a3e635', glow: 'rgba(163, 230, 53, 0.6)' },  // Lime
                'grad-amber':    { stroke: '#fbbf24', glow: 'rgba(251, 191, 36, 0.6)' }   // Amber
            };

            for (const [gradId, colors] of Object.entries(colorMap)) {
                if (fill.includes(gradId)) {
                    return colors;
                }
            }

            // Default cyan for unmatched
            return { stroke: '#22d3ee', glow: 'rgba(34, 211, 238, 0.6)' };
        }

        function unlockNode() {
            if (lockedNodeElement) {
                lockedNodeElement.classList.remove('node-locked');
                lockedNodeElement.classList.remove('node-highlight');
                lockedNodeElement.style.removeProperty('--lock-color');
                lockedNodeElement.style.removeProperty('--lock-glow');
            }
            lockedNodeId = null;
            lockedNodeElement = null;
            showDetail(null);
        }

        function extractNodeId(nodeElement) {
            let id = nodeElement.id;

            if (id) {
                const match = id.match(/flowchart-([^-]+)-\d+|node-([^-]+)/);
                if (match) {
                    return match[1] || match[2];
                }
                id = id.replace(/^(flowchart-|node-)/, '').replace(/-\d+$/, '');
                return id;
            }

            const textElement = nodeElement.querySelector('.nodeLabel, text');
            if (textElement) {
                const text = textElement.textContent.trim();
                for (const key of Object.keys(nodeDetails)) {
                    if (text.toLowerCase().includes(key.toLowerCase())) {
                        return key;
                    }
                }
            }

            return null;
        }

        function highlightNode(node) {
            if (currentHighlight && currentHighlight !== node) {
                currentHighlight.classList.remove('node-highlight');
                currentHighlight.style.removeProperty('--highlight-color');
                currentHighlight.style.removeProperty('--highlight-glow');
            }

            // Set highlight color matching node's gradient
            const colors = getNodeLockColor(node);
            node.style.setProperty('--highlight-color', colors.stroke);
            node.style.setProperty('--highlight-glow', colors.glow);

            node.classList.add('node-highlight');
            currentHighlight = node;
        }

        function unhighlightNode(node) {
            node.classList.remove('node-highlight');
            node.style.removeProperty('--highlight-color');
            node.style.removeProperty('--highlight-glow');
            currentHighlight = null;
        }

        function showDetail(nodeId) {
            const detailOutput = document.getElementById('detail-output');

            if (!nodeId || !nodeDetails[nodeId]) {
                detailOutput.innerHTML = '<div class="detail-placeholder">Hover to see details / Click to lock</div>';
                return;
            }

            detailOutput.innerHTML = `
                <div class="detail-active">
                    <span class="detail-node-id">${nodeId}</span>
                    <div class="detail-text">${nodeDetails[nodeId]}</div>
                </div>
            `;
        }

        // ========== Resizable Panels ==========

        function initResizers() {
            const mainResizer = document.getElementById('resizer-main');
            const leftVResizer = document.getElementById('resizer-left-v');

            // Main horizontal resizer (between left and right columns)
            initHorizontalResizer(mainResizer, 'left-column', 'right-column');

            // Left vertical resizer (between mermaid code and details)
            initVerticalResizer(leftVResizer, 'panel-mermaid', 'panel-details');

            // Right column resizer with layout switching capability
            initRightColumnResizer();
        }

        function initHorizontalResizer(resizer, leftId, rightId) {
            const leftEl = document.getElementById(leftId);
            const container = document.getElementById('main-container');

            let startX, startWidth;

            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startX = e.clientX;
                startWidth = leftEl.offsetWidth;

                document.body.classList.add('resizing');
                resizer.classList.add('active');

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            function onMouseMove(e) {
                const dx = e.clientX - startX;
                const newWidth = Math.max(200, Math.min(startWidth + dx, container.offsetWidth - 300));
                leftEl.style.width = newWidth + 'px';
                leftEl.style.flex = 'none';
            }

            function onMouseUp() {
                document.body.classList.remove('resizing');
                resizer.classList.remove('active');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
        }

        function initVerticalResizer(resizer, topId, bottomId) {
            const topEl = document.getElementById(topId);
            const bottomEl = document.getElementById(bottomId);
            const parent = topEl.parentElement;

            let startY, startTopHeight, startBottomHeight;

            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startY = e.clientY;
                startTopHeight = topEl.offsetHeight;
                startBottomHeight = bottomEl.offsetHeight;

                document.body.classList.add('resizing', 'row-resize');
                resizer.classList.add('active');

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            function onMouseMove(e) {
                const dy = e.clientY - startY;
                const totalHeight = startTopHeight + startBottomHeight;

                let newTopHeight = startTopHeight + dy;
                let newBottomHeight = startBottomHeight - dy;

                // Minimum heights
                const minHeight = 80;
                if (newTopHeight < minHeight) {
                    newTopHeight = minHeight;
                    newBottomHeight = totalHeight - minHeight;
                }
                if (newBottomHeight < minHeight) {
                    newBottomHeight = minHeight;
                    newTopHeight = totalHeight - minHeight;
                }

                topEl.style.flex = 'none';
                bottomEl.style.flex = 'none';
                topEl.style.height = newTopHeight + 'px';
                bottomEl.style.height = newBottomHeight + 'px';
            }

            function onMouseUp() {
                document.body.classList.remove('resizing', 'row-resize');
                resizer.classList.remove('active');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
        }

        // Special resizer for right column that supports layout switching
        function initRightColumnResizer() {
            const resizer = document.getElementById('resizer-right-v');
            const rightColumn = document.getElementById('right-column');
            const diagramPanel = document.getElementById('panel-diagram');
            const detailPanel = document.getElementById('panel-detail');

            let startX, startY, startDiagramSize, startDetailSize;
            let isHorizontal = false;
            let layoutSwitching = false; // Flag to prevent style changes during layout switch

            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startX = e.clientX;
                startY = e.clientY;
                isHorizontal = rightColumn.classList.contains('horizontal-layout');
                layoutSwitching = false;

                if (isHorizontal) {
                    startDiagramSize = diagramPanel.offsetWidth;
                    startDetailSize = detailPanel.offsetWidth;
                    document.body.classList.add('resizing');
                } else {
                    startDiagramSize = diagramPanel.offsetHeight;
                    startDetailSize = detailPanel.offsetHeight;
                    document.body.classList.add('resizing', 'row-resize');
                }

                resizer.classList.add('active');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            function onMouseMove(e) {
                // Skip if layout is switching
                if (layoutSwitching) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                if (isHorizontal) {
                    // Check if dragging down to switch back to vertical
                    if (dy > 80) {
                        switchToVerticalLayout();
                        return;
                    }

                    // Horizontal layout - resize widths
                    const totalWidth = startDiagramSize + startDetailSize;
                    let newDiagramWidth = startDiagramSize + dx;
                    let newDetailWidth = startDetailSize - dx;

                    const minWidth = 150;
                    if (newDiagramWidth < minWidth) {
                        newDiagramWidth = minWidth;
                        newDetailWidth = totalWidth - minWidth;
                    }
                    if (newDetailWidth < minWidth) {
                        newDetailWidth = minWidth;
                        newDiagramWidth = totalWidth - minWidth;
                    }

                    diagramPanel.style.flex = 'none';
                    detailPanel.style.flex = 'none';
                    diagramPanel.style.width = newDiagramWidth + 'px';
                    diagramPanel.style.height = '100%';
                    detailPanel.style.width = newDetailWidth + 'px';
                    detailPanel.style.height = '100%';
                } else {
                    // Check if dragging right to switch to horizontal layout
                    if (dx > 100) {
                        switchToHorizontalLayout();
                        return;
                    }

                    // Vertical layout - resize heights
                    const totalHeight = startDiagramSize + startDetailSize;
                    let newDiagramHeight = startDiagramSize + dy;
                    let newDetailHeight = startDetailSize - dy;

                    const minHeight = 80;
                    if (newDiagramHeight < minHeight) {
                        newDiagramHeight = minHeight;
                        newDetailHeight = totalHeight - minHeight;
                    }
                    if (newDetailHeight < minHeight) {
                        newDetailHeight = minHeight;
                        newDiagramHeight = totalHeight - minHeight;
                    }

                    diagramPanel.style.flex = 'none';
                    detailPanel.style.flex = 'none';
                    diagramPanel.style.height = newDiagramHeight + 'px';
                    detailPanel.style.height = newDetailHeight + 'px';
                }
            }

            function switchToHorizontalLayout() {
                layoutSwitching = true;
                rightColumn.classList.add('horizontal-layout');
                isHorizontal = true;

                // Completely reset all inline styles for horizontal layout
                diagramPanel.style.cssText = '';
                detailPanel.style.cssText = '';

                // End current drag operation and show feedback
                endDragAndReset();
                showLayoutHint('Horizontal Layout');
            }

            function switchToVerticalLayout() {
                layoutSwitching = true;
                rightColumn.classList.remove('horizontal-layout');
                isHorizontal = false;

                // Completely reset all inline styles for vertical layout
                diagramPanel.style.cssText = '';
                detailPanel.style.cssText = '';

                // End current drag operation and show feedback
                endDragAndReset();
                showLayoutHint('Vertical Layout');
            }

            function endDragAndReset() {
                // Remove event listeners to stop drag
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);

                // Clean up UI state
                document.body.classList.remove('resizing', 'row-resize');
                resizer.classList.remove('active');

                // Reset after a short delay to allow CSS transition
                setTimeout(() => {
                    layoutSwitching = false;
                }, 100);
            }

            function onMouseUp() {
                document.body.classList.remove('resizing', 'row-resize');
                resizer.classList.remove('active');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
        }

        // Visual feedback for node lock
        function showLockHint(text) {
            let hint = document.getElementById('lock-hint');
            if (!hint) {
                hint = document.createElement('div');
                hint.id = 'lock-hint';
                hint.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    right: 30px;
                    background: linear-gradient(135deg, rgba(129, 140, 248, 0.95), rgba(34, 211, 238, 0.95));
                    color: white;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-weight: 600;
                    font-size: 12px;
                    z-index: 1000;
                    pointer-events: none;
                    transition: opacity 0.3s ease;
                    backdrop-filter: blur(8px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                `;
                document.body.appendChild(hint);
            }
            hint.textContent = text;
            hint.style.opacity = '1';
            setTimeout(() => {
                hint.style.opacity = '0';
            }, 1500);
        }

        // Visual feedback for layout switch
        function showLayoutHint(text) {
            let hint = document.getElementById('layout-hint');
            if (!hint) {
                hint = document.createElement('div');
                hint.id = 'layout-hint';
                hint.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(168, 85, 247, 0.9);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 1000;
                    pointer-events: none;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(hint);
            }
            hint.textContent = text;
            hint.style.opacity = '1';
            setTimeout(() => {
                hint.style.opacity = '0';
            }, 1000);
        }

        // ========== Initialization ==========

        document.addEventListener('DOMContentLoaded', () => {
            initResizers();
            changeTheme('glassmorphism');
        });

        // Ctrl+Enter to render
        document.querySelectorAll('textarea').forEach(textarea => {
            textarea.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    renderDiagram();
                }
            });
        });

        // ========== Theme System ==========

        const themes = {
            glassmorphism: {
                name: 'Glassmorphism Dark',
                body: { background: 'linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%)' },
                header: { background: 'rgba(255,255,255,0.08)', backdropFilter: 'blur(20px)', border: '1px solid rgba(255,255,255,0.15)', boxShadow: '0 8px 32px rgba(0,0,0,0.4)' },
                panel: { background: 'rgba(255,255,255,0.06)', backdropFilter: 'blur(20px)', border: '1px solid rgba(255,255,255,0.12)', boxShadow: '0 8px 32px rgba(0,0,0,0.3)' },
                panelHeader: { background: 'rgba(255,255,255,0.08)', color: 'rgba(255,255,255,0.8)' },
                diagram: { background: 'rgba(255,255,255,0.95)', dots: 'rgba(168, 85, 247, 0.15)' },
                text: { primary: '#fff', secondary: 'rgba(255,255,255,0.6)' },
                accent: '#a855f7',
                mermaid: {
                    theme: 'base',
                    primaryColor: '#a855f7',
                    primaryTextColor: '#1e1b4b',
                    primaryBorderColor: '#9333ea',
                    lineColor: '#a78bfa',
                    secondaryColor: '#faf5ff',
                    background: '#ffffff'
                }
            },
            minimal: {
                name: 'Soft Minimal Light',
                body: { background: 'linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%)' },
                header: { background: 'rgba(255,255,255,0.8)', backdropFilter: 'blur(10px)', borderBottom: '1px solid rgba(226, 232, 240, 0.8)', boxShadow: '0 1px 3px rgba(0,0,0,0.04)' },
                panel: { background: 'rgba(255,255,255,0.9)', border: '1px solid rgba(226, 232, 240, 0.6)', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -2px rgba(0, 0, 0, 0.05)' },
                panelHeader: { background: 'linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%)', color: '#475569', borderBottom: '1px solid #e2e8f0' },
                diagram: { background: '#ffffff', dots: '#e2e8f0' },
                text: { primary: '#0f172a', secondary: '#64748b' },
                accent: '#3b82f6',
                mermaid: {
                    theme: 'base',
                    primaryColor: '#3b82f6',
                    primaryTextColor: '#0f172a',
                    primaryBorderColor: '#2563eb',
                    lineColor: '#94a3b8',
                    secondaryColor: '#f1f5f9',
                    background: '#ffffff'
                }
            }
        };

        let currentTheme = 'glassmorphism';

        function changeTheme(themeName) {
            currentTheme = themeName;
            const theme = themes[themeName];
            if (!theme) return;

            const body = document.body;
            const header = document.querySelector('.header');
            const panels = document.querySelectorAll('.panel');
            const panelHeaders = document.querySelectorAll('.panel-header');
            const diagramOutput = document.getElementById('diagram-output');
            const themeSelector = document.getElementById('theme-selector');
            const btn = document.querySelector('.btn');
            const shortcutHint = document.querySelector('.shortcut-hint');

            // Apply body styles
            Object.assign(body.style, theme.body);

            // Apply header styles
            header.style.background = theme.header.background;
            header.style.backdropFilter = theme.header.backdropFilter || 'none';
            header.style.borderBottom = theme.header.borderBottom || 'none';
            header.style.boxShadow = theme.header.boxShadow || '0 4px 20px rgba(0,0,0,0.3)';
            if (theme.header.border) header.style.border = theme.header.border;

            // Apply panel styles
            panels.forEach(panel => {
                panel.style.background = theme.panel.background;
                panel.style.backdropFilter = theme.panel.backdropFilter || 'none';
                panel.style.border = theme.panel.border || 'none';
                panel.style.boxShadow = theme.panel.boxShadow || '0 8px 32px rgba(0,0,0,0.3)';
            });

            // Apply panel header styles
            panelHeaders.forEach(ph => {
                ph.style.background = theme.panelHeader.background;
                ph.style.color = theme.panelHeader.color;
                ph.style.borderBottom = theme.panelHeader.borderBottom || '1px solid rgba(255,255,255,0.1)';
            });

            // Apply diagram output styles
            if (theme.diagram.dots) {
                diagramOutput.style.background = `radial-gradient(circle at 1px 1px, ${theme.diagram.dots} 1px, transparent 0)`;
                diagramOutput.style.backgroundSize = '20px 20px';
                diagramOutput.style.backgroundColor = theme.diagram.background;
            } else {
                diagramOutput.style.background = theme.diagram.background;
            }

            // Theme-specific styling for light/dark modes
            const isLight = themeName === 'minimal';

            // Update header text colors
            document.querySelectorAll('.header h1').forEach(el => el.style.color = isLight ? '#1e293b' : '#fff');
            document.querySelectorAll('.header p').forEach(el => el.style.color = isLight ? '#64748b' : 'rgba(255,255,255,0.85)');

            // Update textarea styles
            document.querySelectorAll('textarea').forEach(el => {
                el.style.color = isLight ? '#1e293b' : '#a8e6cf';
                el.style.background = isLight ? '#ffffff' : '#0f0f23';
                el.style.borderColor = isLight ? '#e2e8f0' : 'rgba(255,255,255,0.1)';
            });

            // Update detail panel text
            document.querySelectorAll('.detail-text').forEach(el => {
                el.style.color = isLight ? '#475569' : '#e2e8f0';
            });

            // Update theme selector styling
            themeSelector.style.background = isLight ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.15)';
            themeSelector.style.color = isLight ? '#1e293b' : '#fff';
            themeSelector.style.borderColor = isLight ? '#cbd5e1' : 'rgba(255,255,255,0.3)';

            // Update button styling
            btn.style.background = isLight ? theme.accent : 'rgba(255,255,255,0.2)';
            btn.style.color = isLight ? '#fff' : '#fff';
            btn.style.borderColor = isLight ? theme.accent : 'rgba(255,255,255,0.3)';

            // Update shortcut hint
            shortcutHint.style.color = isLight ? '#64748b' : 'rgba(255,255,255,0.6)';

            // Update zoom controls
            document.querySelectorAll('.zoom-btn').forEach(el => {
                el.style.background = `rgba(${isLight ? '59, 130, 246' : '102, 126, 234'}, 0.9)`;
            });

            // Update detail node ID badge based on theme
            const detailNodeId = document.querySelector('.detail-node-id');
            if (detailNodeId) {
                if (themeName === 'minimal') {
                    detailNodeId.style.background = 'linear-gradient(135deg, #3b82f6, #06b6d4)';
                    detailNodeId.style.color = '#fff';
                } else {
                    // glassmorphism (default) - indigo to cyan
                    detailNodeId.style.background = 'linear-gradient(135deg, #818cf8, #22d3ee)';
                    detailNodeId.style.color = '#fff';
                }
            }

            // Update resizer accent colors
            const accentColors = {
                glassmorphism: 'rgba(168, 85, 247, 0.5)',
                minimal: 'rgba(59, 130, 246, 0.5)'
            };
            document.documentElement.style.setProperty('--resizer-accent', accentColors[themeName] || accentColors.glassmorphism);

            // Update placeholder text color
            document.querySelectorAll('.detail-placeholder').forEach(el => {
                el.style.color = isLight ? '#94a3b8' : '#64748b';
            });

            // Reinitialize Mermaid with new theme and re-render
            updateMermaidTheme(theme.mermaid);
            renderDiagram();
        }

        function updateMermaidTheme(mermaidTheme) {
            mermaid.initialize({
                startOnLoad: false,
                theme: mermaidTheme.theme,
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: false,
                    htmlLabels: true,
                    curve: 'basis',
                    padding: 20,
                    nodeSpacing: 50,
                    rankSpacing: 60
                },
                themeVariables: {
                    primaryColor: mermaidTheme.primaryColor,
                    primaryTextColor: mermaidTheme.primaryTextColor,
                    primaryBorderColor: mermaidTheme.primaryBorderColor,
                    lineColor: mermaidTheme.lineColor,
                    secondaryColor: mermaidTheme.secondaryColor,
                    background: mermaidTheme.background,
                    mainBkg: mermaidTheme.background,
                    nodeBorder: mermaidTheme.primaryBorderColor,
                    edgeLabelBackground: 'transparent',
                    fontFamily: '"Segoe UI", "Meiryo", sans-serif',
                    fontSize: '14px'
                }
            });
        }
    </script>
</body>
</html>
